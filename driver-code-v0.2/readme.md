Driver Code
===========

This folder contains the driver code to be run on an STM32. Many files are autogenerated by the IDE, and
therefore there is a lot code. All the (non-generated) application code is under the folder `Code`, written
in C++.

Highlighted files:
```ini
.
├── Code
│   ├── Inc
│   │   ├── app_main.hpp         # Main application entry point.
│   │   └── interrupts.hpp       # Interrupt handler definitions.
│   └── Src
│       ├── app_main.cpp         # After initialization the main app loop only handles comms and timekeeping.
│       │
│       └── interrupts.cpp       # Motor control logic! All motor control logic runs in the interrupt loop with
│                                # internal message passing to the main loop for data readouts and new commands.
│                                # 
│                                # We run a lot of code in the interrupts because motor control is the critical 
│                                # function of this driver chip. We do what we must because we can! The interrupt
│                                # is triggered when the ADC measures a set of phase currents. We must immediately
│                                # do math to transform the currents into the DQ0 frame and use those calculations
│                                # to set the motor PWM outputs for the upcoming cycle.
│
├── Core
│   └── Src
│       ├── main.c               # Invokes the app_main functions, otherwise it is autogenerated.
│       ├── stm32f1xx_it.c       # Invokes the interrupts, also autogenerated.
└── USB_DEVICE
    └── App
        └── usbd_cdc_if.c        # Invokes the USB send and receive functions, autogenerated.
#TODO: list all files mentioned in the section below.
```

New STM32 setup procedure
-------------------------

Install `STM32 Cube IDE / STM32 Cube MX`.

We need to configure CubeMX for our new board with the required peripherals:

From the `Project Manager` tab select `Project` and switch `Toolchain / IDE` to `CMake`.

* System Core:
    + NVIC: Ensure the `ADC1 and ADC2 global interrupt` is activated.
    + RCC: Switch High Speed Clock to `Crystal/Ceramic Resonator`.
    + SYS: Enable `Serial Wire` for debug and switch `Timebase Source` to any other time; we need to leave `SysTick` free in case we enable RTOS.
* Timers:
    + TIM1: Setup 4 channels with positive and negative PWM (8 pins). 
    Set `Counter Mode` to `Center Aligned mode1`. 
    Set an extra channel as `PWM Generation No Output` for timing the analog reads.
    Enable `auto-reload preload`.
    Set `Trigger Event Selection TRGO2` to `Output Compare (OC5REF)` so we can use it to time the ADC reads.
    + TIM2 & TIM4: Setup 3 PWM channels for the status LED; set `Channel Polarity` to `Low`.
    + TIM3: Set `Combined Channels` to `XOR ON / Hall Sensor Mode`, leave the rest default.
* Connectivity:
    + I2C2 & I2C3: Enable on default settings.
    + SPI3: Enable as `Full-Duplex Slave` with `Hardware NSS Input Signal`. I set `Frame Format` to `TI` and `Data Size` to `8 Bits`, but not sure of right settings yet.
    + USART3: Enable `Asynchornous` mode.
    + USB: Enable it on the `Internal Phy`.
* Analog ADC1 & ADC2:
    + Set `ADCs_Common_Settings` to `Dual combined regular simultaneous + injected simultaneous`.
    + Set `External Trigger Source` to `Timer 1 Trigger Out event 2`.


Open `hex-mini-driver.ioc` and use the `Generate Code` tool from the STM32 Cube IDE.

After generating the CubeMX configuration code we need to make the following changes:
    1. Make sure it compiles... The `CMakeFiles` are generated once and then left to the user to edit, we must include all used libraries. Since Cube MX doesn't update the make files it won't add libraries that we enable after the first time we autogenerate code.
    2. Copy `USB_DEVICE/App/usbd_cdc_if.c`. It contains the circular buffer implementation for USB data. It must remain implemented here because Cube MX autogenerates the functions as private to this file.
    3. In `Core/Src/main.c` we must add the includes:
        `
        #include "app_main.hpp"
        #include "error_handler.hpp"
        `
    then insert our initialization and infinite loop at the end of the Cube MX initialization that we configured in the Cube IDE:
        `
          /* Infinite loop */
          /* USER CODE BEGIN WHILE */
          app_init();
          while (1) {
            /* USER CODE END WHILE */
            /* USER CODE BEGIN 3 */
            app_tick();
          }
          /* USER CODE END 3 */
        `
    and finally, use our C++ error handler:
        `
        void Error_Handler(void)
        {
          /* USER CODE BEGIN Error_Handler_Debug */
          /* User can add his own implementation to report the HAL error return state */
          error();
          /* USER CODE END Error_Handler_Debug */
        }
        `
    4. In `Core/Src/stm32..xx_it.c` add our C++ interrupt handlers to the Cube MX generated interrupt handlers:
        `
        /* USER CODE BEGIN Includes */
        #include "interrupts.hpp"
        /* USER CODE END Includes */
        `
    after the includes, we must invoke the adc interrupt:
        `  
        /* USER CODE BEGIN ADC1_2_IRQn 0 */
        adc_interrupt_handler();
        /* USER CODE END ADC1_2_IRQn 0 */
        `
    That's it for the autogenerated code mixing; our code should now all be in `Code`.
    5. Copy the `Code` folder over.
    6. Add our sources and include paths to `CMakeLists.txt`, the first 3 listed here, copy the rest from the previous `CMakeLists.txt`:
        `
        # Add sources to executable
        target_sources(${CMAKE_PROJECT_NAME} PRIVATE
            # Add user sources here
            "Code/Src/app_main.cpp"
            "Code/Src/io.cpp"
            "Code/Src/error_handler.cpp"
        )
        # Add include paths
        target_include_directories(${CMAKE_PROJECT_NAME} PRIVATE
            # Add user defined include paths
            "Code/Inc"
        )
        `
    7. Update `cmake/gcc-arm-none-eabi.cmake` with our C++ build flags:
        `
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra -Wpedantic -fdata-sections -ffunction-sections -Wno-unused-parameter")
        set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -std=gnu++23 -fno-rtti -fno-exceptions -fno-threadsafe-statics -Wno-register -Wno-narrowing -Werror=switch")
        `
    8. Edit the linker script, a file that looks like `stm32.*_flash.ld`, we need to reserve a small section for user data.
    Edit the `MEMORY` section according to the target chip, must look like:
        `
        /* Specify the memory areas */
        MEMORY
        {
        RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 32K
        FLASH (rx)      : ORIGIN = 0x8000000, LENGTH = 120K
        DATA (xrw)      : ORIGIN = 0x801E000, LENGTH = 8K
        }
        `
    We must add the name for our section inside `SECTIONS`:
        `
          /* Reserve the last pages of flash for user data (calibration). */
          .user_data (NOLOAD) : {
            . = ALIGN(4);
            KEEP(*(.user_data))
            . = ALIGN(4);
          } > DATA
        `
    Fix the linker warning by adding `(READONLY)` to the following lines, also inside `SECTIONS`:
        `
          .preinit_array (READONLY) :
          .init_array (READONLY) :
          .fini_array (READONLY) :
        `
    9. Attach the GPIO outputs to the proper routines (TODO: need a file where the pinout is defined all together).
    10. To properly setup VSCode we must copy over these files:
        * `.vscode/c_cpp_properties.json`
        * `.vscode/tasks.json`
        * `.vscode/launch.json`


TODO: install procedure
TODO: compile procedure
TODO: upload procedure
TODO: control interface description
TODO: update the file descriptions above

TODO: ... fix error handler, must stop motor disable IRQ and display LED.
TODO: rename the interrupts based on what they do rather than the STM32 interrupt source.
