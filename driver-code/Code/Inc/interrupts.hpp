#pragma once


#ifdef __cplusplus
extern "C" {
#endif

void adc_interrupt_handler();
void dma_interrupt_handler();
void tim1_update_interrupt_handler();
void tim1_trigger_and_commutation_interrupt_handler();
void tim2_global_handler();


#ifdef __cplusplus
}

// The autogenerated code defaults to C which calls our functions above; otherwise *we* prefer using C++.

#include "constants.hpp"

#include "FreeRTOS.h"
#include "queue.h"

#include <cstdint>
#include <cstddef>


extern uint32_t adc_update_number;
extern uint32_t hall_unobserved_number;
extern uint32_t hall_observed_number;

// Cycle state
// -----------

struct StateReadout{
    uint16_t readout_number;
    uint16_t u_readout;
    uint16_t v_readout;
    uint16_t w_readout;
    uint16_t ref_readout;
    uint16_t position;
    uint32_t pwm_commands;
};

extern StateReadout latest_readout;


// Data queue
// ----------

const size_t READOUT_ITEMSIZE = sizeof(StateReadout);


extern QueueHandle_t readouts_queue;
extern StaticQueue_t readouts_queue_storage;
extern uint8_t readouts_queue_buffer[HISTORY_SIZE * READOUT_ITEMSIZE];

extern uint32_t readouts_missed;

// Initialize the queue for data passing from interrupt.
void data_init();

// Initialize the angle tracking system on startup to read the initial hall sensor state.
void initialize_position_tracking();

// Setup ADC for reading motor phase currents.
void adc_init();

// Select which interrupts to handle.
void interrupts_init();

// Enable the timers to start the ADC and motor control loops.
void enable_timers();

// End ifdef __cplusplus
#endif