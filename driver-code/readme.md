Driver Code
===========

This folder contains the driver code to be run on an STM32. Many files are autogenerated by the IDE, and
therefore there is a lot code. All the (non-generated) application code is under the folder `Code`, written
in C++.

Highlighted files:
```ini
.
├── Code
│   ├── Inc
│   │   ├── app_main.hpp         # Main application entry point.
│   │   └── interrupts.hpp       # Interrupt handler definitions.
│   └── Src
│       ├── app_main.cpp         # After initialization the main app loop only handles comms and timekeeping.
│       │
│       └── interrupts.cpp       # Motor control logic! All motor control logic runs in the interrupt loop with
│                                # internal message passing to the main loop for data readouts and new commands.
│                                # 
│                                # We run a lot of code in the interrupts because motor control is the critical 
│                                # function of this driver chip. We do what we must because we can! The interrupt
│                                # is triggered when the ADC measures a set of phase currents. We must immediately
│                                # do math to transform the currents into the DQ0 frame and use those calculations
│                                # to set the motor PWM outputs for the upcoming cycle.
│
├── Core
│   └── Src
│       ├── main.c               # Invokes the app_main functions, otherwise it is autogenerated.
│       ├── stm32f1xx_it.c       # Invokes the interrupts, also autogenerated.
└── USB_DEVICE
    └── App
        └── usbd_cdc_if.c        # Invokes the USB send and receive functions, autogenerated.
#TODO: list all files mentioned in the section below.
```

New STM32 setup procedure
-------------------------

Install `STM32 Cube IDE / STM32 Cube MX`

Open `hex-mini-driver.ioc` and use the `Generate Code` tool from the STM32 Cube IDE.

After generating the CubeMX configuration code we need to make the following changes:
    1. Make sure it compiles... The `CMakeFiles` are generated once and then left to the user to edit, we must include all used libraries. Since Cube MX doesn't update the make files it won't add libraries that we enable after the first time we autogenerate code.
    2. Copy `USB_DEVICE/App/usbd_cdc_if.c`. It contains the circular buffer implementation for USB data. It must remain implemented here because Cube MX autogenerates the functions as private to this file.
    3. In `Core/Src/main.c` we must add the includes:
        `
        #include "app_main.hpp"
        #include "error_handler.hpp"
        `
    then insert our initialization and infinite loop at the end of the Cube MX initialization that we configured in the Cube IDE:
        `
          /* Infinite loop */
          /* USER CODE BEGIN WHILE */
          app_init();
          while (1) {
            /* USER CODE END WHILE */
            /* USER CODE BEGIN 3 */
            app_tick();
          }
          /* USER CODE END 3 */
        `
    and finally, use our C++ error handler:
        `
        void Error_Handler(void)
        {
          /* USER CODE BEGIN Error_Handler_Debug */
          __disable_irq();
          show_error_on_led();
          while (1)
          {
          }
          /* USER CODE END Error_Handler_Debug */
        }
        `
    4. In `Core/Src/stm32..xx_it.c` add our C++ interrupt handlers to the Cube MX generated interrupt handlers:
        `
        /* USER CODE BEGIN Includes */
        #include "interrupts.hpp"
        /* USER CODE END Includes */
        `
    after the includes, we must tie in the following functions to the appropriate interrupt source:
        `
        adc_interrupt_handler
        tim1_update_interrupt_handler
        tim2_global_handler
        `
    That's it for the autogenerated code mixing; our code should now all be in `Code`.
    5. Copy the `Code` folder over.
    6. Update `CMakeLists.txt` to compile all our code files.
    7. Update `cmake/gcc-arm-none-eabi.cmake` with our C++ build flags:
        `
        set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -std=gnu++23 -fno-rtti -fno-exceptions -fno-threadsafe-statics -Wno-register -Wno-narrowing -Werror=switch")
        `
    8. Edit the linker script, a file that looks like `stm32.*_flash.ld`, we need to reserve a small section for user data.
    Edit the `MEMORY` section according to the target chip, must look like:
        `
        /* Specify the memory areas */
        MEMORY
        {
        RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 32K
        FLASH (rx)      : ORIGIN = 0x8000000, LENGTH = 120K
        DATA (xrw)      : ORIGIN = 0x801E000, LENGTH = 8K
        }
        `
    We must add the name for our section inside `SECTIONS`:
        `
          /* Reserve the last pages of flash for user data (calibration). */
          .user_data (NOLOAD) : {
            . = ALIGN(4);
            KEEP(*(.user_data))
            . = ALIGN(4);
          } > DATA
        `
    Fix the linker warning by adding `(READONLY)` to the following lines, also inside `SECTIONS`:
        `
          .preinit_array (READONLY) :
          .init_array (READONLY) :
          .fini_array (READONLY) :
        `
    9. Attach the GPIO outputs to the proper routines (TODO: need a file where the pinout is defined all together).
    10. To properly setup VSCode we must copy over these files:
        * `.vscode/c_cpp_properties.json`
        * `.vscode/tasks.json`
        * `.vscode/launch.json`

TODO: install procedure
TODO: compile procedure
TODO: upload procedure
TODO: control interface description
TODO: update the file descriptions above

TODO: ... fix error handler, must stop motor disable IRQ and display LED.
TODO: rename the interrupts based on what they do rather than the STM32 interrupt source.
