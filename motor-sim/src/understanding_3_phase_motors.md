---
title: Understanding 3-phase motor control
---

<div class="grid" style="grid-template-columns: 1fr 1fr;">
  <div class="card">
    <figure>${live_simulation}</figure>
    <div class="card tight">${simulation_info}</div>
    <div class="card tight">${simulation_interface}</div>
    <div class="card tight">${simulation_plots_interface}</div>
  </div>
  <div class="card">
    <div class="card tight" style="min-height: 5rem;">${highlight_description}</div>
    <div class="card tight">${simulation_plots}</div>
  </div>
</div>


```js
import * as THREE from "three";
import {formatSI} from "format-si-prefix";
import tex from "npm:@observablehq/tex";
import * as Plot from "@observablehq/plot";
import _ from "lodash";

import {html} from "htl";
const htf = html.fragment;

import {note, link} from "./components/utils.js"
import {Simulation, initial_state, initial_parameters, Ï€, normalized_angle} from "./components/simulation.js"
import {create_scene, setup_rendering} from "./components/visuals.js"


const {motor, scene} = await create_scene();

function get_coil_color(coil) {
  const hsl_color = {};
  coil.material.emissive.getHSL(hsl_color);
  const {h, s, l} = hsl_color;

  return new THREE.Color().setHSL(h, 1.0, 0.3).getStyle();
}

const color_u = get_coil_color(motor.coil_U);
const color_v = get_coil_color(motor.coil_V);
const color_w = get_coil_color(motor.coil_W);
const color_x = "steelblue";
const color_y = "lightcoral";


function update_motor_visuals(state) {
  const {Ï†, I_u, I_v, I_w, hall_1, hall_2, hall_3, rx, ry} = state;
  
  motor.rotor.rotation.y = normalized_angle(Ï† - Ï€ / 2);
  const position_scaling = 50_000.0;
  motor.rotor.position.z = position_scaling * rx;
  motor.rotor.position.x = position_scaling * ry;
  motor.red_led.material.emissiveIntensity = hall_1 ? 10.0 : 0.0;
  motor.green_led.material.emissiveIntensity = hall_2 ? 8.0 : 0.0;
  motor.blue_led.material.emissiveIntensity = hall_3 ? 12.0 : 0.0;
  motor.coil_U.material.emissiveIntensity = 0.20 * Math.abs(I_u / 6.0);
  motor.coil_V.material.emissiveIntensity = 0.20 * Math.abs(I_v / 6.0);
  motor.coil_W.material.emissiveIntensity = 0.15 * Math.abs(I_w / 6.0);
}

const descriptions = new Map([
  ["<no selection>", html`
    We simulate a 3 phase motor with 1 winding per phase and 2 pole permanent magnet rotor
    (to simplify the illustration). However around the model to find out more.`],
  [motor.stator, html`
    The stator is the stationary part of the motor. The coils wounded around the stator slots
    generate a magnetic field when current flows through them. The stator is made of magnetic
    material to guide the magnetic field lines between the stator poles. The hall sensors are
    also fixed to the stator, usually on a small circuit board, here they magically float.`],
  [motor.rotor, html`
    The rotor is the rotating part of the motor. The rotor contains permanent magnets that
    interact with the magnetic field generated by the stator. The rotor is mounted on a shaft
    that is supported by bearings.`],
  [motor.coil_U, html`
    The U phase coil generates a magnetic field when current flows through it. Driving the motor.`],
  [motor.coil_V, html`
    The V phase coil generates a magnetic field when current flows through it. Driving the motor.`],
  [motor.coil_W, html`
    The W phase coil generates a magnetic field when current flows through it. Driving the motor.`],
  [motor.hall_1, html`
    The hall sensor 1 is placed between the U and V phase poles. It senses the north magnetic field.`],
  [motor.hall_2, html`
    The hall sensor 2 is placed between the V and W phase poles. It senses the north magnetic field.`],
  [motor.hall_3, html`
    The hall sensor 3 is placed between the W and U phase poles. It senses the north magnetic field.`],
]);


/* Get the most specific object group with a description from those intersected by the mouse cursor. */
function get_object_with_description(intersected_objects) {
  if (intersected_objects.length == 0) return [];
  let object = intersected_objects[0];
  // Walk the object hierarchy to find the first object with a description.
  while (!descriptions.has(object)) {
    // We reached the top without finding a description, don't highlight anything.
    if (object.parent == null) return [];
    object = object.parent;
  }
  return [object];
}

const highlight_description = Mutable(descriptions.get("<no selection>"));

const show_description = _.throttle((objects) => {
  highlight_description.value = descriptions.get(_.get(objects, "[0]", "<no selection>"));
}, 500);



const frequency_slider = Inputs.range([1_125_000, 72_000_000], {
  transform: Math.log, 
  format: x => x.toFixed(0), 
  label: "Frequency (Hz)",
});

const steps_number_slider = Inputs.range([1, 20_000], {
  transform: Math.log, 
  format: x => x.toFixed(0), 
  label: "Steps per frame",
});

const store_period_slider = Inputs.range([1, 10_000], {
  transform: Math.log, 
  format: x => x.toFixed(0), 
  label: "Store period",
});



const load_torque_slider = Inputs.range([0.000_1, 0.02], {
  transform: Math.log,
  format: x => x.toFixed(4),
  label: "Load Torque",
});
const load_torque_angle = Inputs.range([-180, +180], {
  format: x => x.toFixed(0),
  label: "Load Torque Angle",
});

const load_torque_map = {
  "Free": ()=>0.0,
  "Move +": ()=>load_torque_slider.value,
  "Move -": ()=>-load_torque_slider.value,
  "Towards Angle": (Ï†)=>load_torque_slider.value * normalized_angle(load_torque_angle.value / 180 * Ï€ - Ï†) / (Ï€ / 2),
};
const load_torque_selection = Inputs.radio(Object.keys(load_torque_map), {label: "Load Torque Mode"}); 


function get_sixstep_hall_code(hall_1, hall_2, hall_3){
  return hall_3 << 2 | hall_2 << 1 | hall_1;
}

const sixstep_phase_map = {
  0b000: "no_magnet",
  0b100: 0,
  0b110: 1,
  0b010: 2,
  0b011: 3,
  0b001: 4,
  0b101: 5,
  0b111: "too_much_magnet",
};

const sixstep_switching_neg_map = {
  no_magnet: [0, 0, 0],
  too_much_magnet: [0, 0, 0],
  0: [0, 1, 2],
  1: [1, 0, 2],
  2: [1, 2, 0],
  3: [0, 2, 1],
  4: [2, 0, 1],
  5: [2, 1, 0],
};

const sixstep_switching_pos_map = {
  no_magnet: [0, 0, 0],
  too_much_magnet: [0, 0, 0],
  0: [0, 2, 1],
  1: [2, 0, 1],
  2: [2, 1, 0],
  3: [0, 1, 2],
  4: [1, 0, 2],
  5: [1, 2, 0],
};

function sixstep_commutation(outputs, positive=true){
  const {hall_1, hall_2, hall_3} = outputs;
  const sixstep_phase = sixstep_phase_map[get_sixstep_hall_code(hall_1, hall_2, hall_3)];
  return (positive ? sixstep_switching_pos_map : sixstep_switching_neg_map)[sixstep_phase];
}

const driver_state_map = {
  "Disconnect Battery": ()=>[0, 0, 0],
  "Connect and Idle": ()=>[0, 0, 0],
  "Break": ()=>[2, 2, 2],
  "Drive -": (state, parameters, outputs, update_memory)=>sixstep_commutation(outputs, false),
  "Drive +": (state, parameters, outputs, update_memory)=>sixstep_commutation(outputs, true),
  "Drive U +": ()=>[1, 2, 2],
  "Drive V +": ()=>[2, 1, 2],
  "Drive W +": ()=>[2, 2, 1],
  "Drive U -": ()=>[2, 1, 1],
  "Drive V -": ()=>[1, 2, 1],
  "Drive W -": ()=>[1, 1, 2],
  "Drive UV +": ()=>[1, 2, 0],
  "Drive VW +": ()=>[0, 1, 2],
  "Drive WU +": ()=>[2, 0, 1],
  "Drive UV -": ()=>[2, 1, 0],
  "Drive VW -": ()=>[0, 2, 1],
  "Drive WU -": ()=>[1, 0, 2],
};

const driver_state_selection = Inputs.radio(Object.keys(driver_state_map), {label: "Driver control"});


function update_input(input, value) {
  input.value = value;
  input.dispatchEvent(new Event("input"));
}

function reset() {
  update_input(frequency_slider, 12_000_000); // We want to simulate 72 MHz!
  update_input(steps_number_slider, 2500);
  update_input(store_period_slider, 250);
  update_input(load_torque_slider, +0.01);
  update_input(load_torque_angle, 0.0);
  update_input(load_torque_selection, "Move +");
  update_input(driver_state_selection, "Connect and Idle");
}

reset();


function interactive_inputs(state, parameters, outputs, update_memory) {
  const {Ï†} = state;
  const [U_switch, V_switch, W_switch] = driver_state_map[driver_state_selection.value](state, parameters, outputs, update_memory);

  const Ï„_load = load_torque_map[load_torque_selection.value](Ï†);

  return {
    U_switch, // driver connection state for phase U
    V_switch, // driver connection state for phase V
    W_switch, // driver connection state for phase W
    Ï„_load, // external load torque
    battery_connected: driver_state_selection.value != "Disconnect Battery", // whether the battery is connected
  }
}

const rendering = setup_rendering(scene, invalidation, {highlight_filter: get_object_with_description, on_selection: show_description});

let simulation = new Simulation({
  start_state: initial_state,
  parameters: initial_parameters,
  update_inputs: interactive_inputs,
  update_memory: {},
  dt: 1.0 / frequency_slider.value,
});

const sound_scaling = {
  r: 1.0 / 0.002,
  rv: 1.0 / 1.0,
}


const simulation_control = Inputs.button(
  [
    ["Pause", () => { simulation.running = () => false; }], 
    ["Resume", () => { simulation.running = () => true; }],
    ["Step", () => { 
      let stepped = false; 
      simulation.running = () => { 
        if (stepped) return false;
        stepped = true; 
        return true; 
      };
    }],
    [html`<div style="min-width: 7em;">Look at motor</div>`, () => { rendering.reset_camera(); }],
    [html`<div style="min-width: 6em;">Reset inputs</div>`, () => { reset(); }],
    ["PlayðŸŽµ", () => {
      const audio_context = new AudioContext({sampleRate: simulation.options.sound_sample_rate});

      // Create an empty three-second stereo buffer at the sample rate of the AudioContext.
      const noise_buffer = audio_context.createBuffer(
        2,
        simulation.options.sound_buffer_size,
        simulation.options.sound_sample_rate,
      );

      const left_channel = noise_buffer.getChannelData(0);
      const right_channel = noise_buffer.getChannelData(1);

      const scaling_r = 1.0 / 0.000_100;
      const scaling_rv = 1.0 / 0.100;

      simulation.sounds.forEach(({rx_v, ry_v, rx, ry, r, r_v}, i) => {
        // left_channel[i] = scaling_r * rx + sound_scaling.rv * rx_v;
        // right_channel[i] = scaling_r * ry + sound_scaling.rv * ry_v;

        left_channel[i] = scaling_r * rx;
        // right_channel[i] = scaling_r * ry;

        left_channel[i] = sound_scaling.rv * rx_v;
        // right_channel[i] = sound_scaling.rv * ry_v;
      });

      // Create a buffer source.
      const noise = audio_context.createBufferSource();
      noise.buffer = noise_buffer;

      // Connect to output.
      noise.connect(audio_context.destination);

      // Start the noise.
      noise.start();
    }],
  ],
  {label: "Simulation control"}
);



const simulation_interface = htf`<span>
  <div>${simulation_control}</div>
  <div>${frequency_slider}</div>
  <div>${steps_number_slider}</div>
  <div>${store_period_slider}</div>
  <div>${load_torque_selection}</div>
  <div>${load_torque_slider}</div>
  <div>${load_torque_angle}</div>
  <div>${driver_state_selection}</div>
</span>`;

const number_of_plot_points = 400;

let simulation_info = Mutable(300);

const show_simulation_info = _.throttle((simulation, rendering) => {
  const plot_duration = simulation.options.dt * simulation.options.store_period * number_of_plot_points;

  simulation_info.value = htf`<span style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr">
    <span>FPS: ${rendering.stats.fps.toFixed(1)}</span>
    <span>Slowdown: ${simulation.running ? formatSI(simulation.slowdown) : tex`\infty`}</span>
    <span>Speed: ${formatSI(1.0 / simulation.options.dt)}Hz</span>
    <span>${tex`\delta t`}: ${formatSI(simulation.options.dt)}s</span>

    <span>Plot window: ${formatSI(plot_duration)}s</span>
    <span>Window freq: ${formatSI(1.0 / plot_duration)}Hz</span>
    <span>Buffer: ${formatSI(simulation.history_buffer.size() * simulation.options.store_period * simulation.options.dt)}s</span>
    <span>ðŸŽµ buffer: ${formatSI(simulation.sound_buffer.size() / simulation.options.sound_sample_rate)}s</span>
  </span>`;
}, 100);


const plot_labels_map = {
  "Latest Value": (values) => values.map((row) => _.last(row)),
  "Root Mean Square": (values) => values.map((row) => Math.hypot(...row) / Math.sqrt(row.length)),
  "Hide": (values) => values.map(() => undefined),
};

const plot_labels_choice = Inputs.radio(Object.keys(plot_labels_map), {label: "Show numbers", value: "Root Mean Square"});

const default_sparkline_plot = {label: "<sparkline>", y: [], stroke: "black"};
const default_sparkline_options = {x: "t", least_domain: null, symmetric_domain: true, height: 60, units: ""};

function sparkline(data, title, lines={}, options={}){
  const {x, least_domain, symmetric_domain, height, units} = Object.assign({}, default_sparkline_options, options);
  
  if (!Array.isArray(lines)) lines = [lines];

  lines.map((line) => Object.assign({}, default_sparkline_plot, line));

  const values = lines.map(({y}) => {
    if (typeof y === "string") return data.map((item) => item[y]);
    if (typeof y === "function") return data.map((item) => y(item));
    return y;
  });

  const min_value = Math.min(...values.map(row => Math.min(...row)));
  const max_value = Math.max(...values.map(row => Math.max(...row)));

  const min_domain = least_domain ? Math.min(least_domain[0], min_value) : min_value;
  const max_domain = least_domain ? Math.max(least_domain[1], max_value) : max_value;

  const domain = symmetric_domain ? [
    Math.min(min_domain, -max_domain),
    Math.max(max_domain, -min_domain),
  ] : [
    min_domain,
    max_domain,
  ];

  
  const selected_values = plot_labels_map[plot_labels_choice.value](values);

  const sub_labels = lines.map(({label, stroke}, i) => {
    const v = selected_values[i];
    const formatted_v = v === undefined ?  "" : `${v > 0.0 ? "+" : v < 0.0 ? "-" : ""}${formatSI(Math.abs(v))}${units}`;
    return htf`<div style="color: ${stroke};">${tex`${label}`} <span style="font-family: monospace; float: right;">${formatted_v}</span></div>`
  });
  
  const labels = htf`<div style="display: flex: flex-direction: column; min-width: 150px; margin-right: 6.5px;">
    <div style="font-weight: bold;">${title}</div>
    ${sub_labels}
  </div>`;

  const plot = Plot.plot({
    height,
    axis: null,
    figure: true,
    y: {domain},
    marks:[
      lines.map(({stroke}, i) => Plot.lineY(data, {x, y: values[i], stroke})),
      Plot.ruleY([0], {stroke: "gray", strokeDasharray: "8,2", curve: "linear"}),
    ],
  });

  return htf`<div style="margin: 10px 0px; padding: 5px 0px; box-shadow: 3px 3px 5px rgb(0 0 0 / .2); display: flex; flex-direction: row;">
    ${labels}
    ${plot}
  </div>`;
}

const simulation_plots_map = {
  "Rotational Frequency": [{label: `freq`, y: (item) => item.Ï‰ / (2 * Ï€)}, {least_domain: [-1_000, 1_000], units: "Hz"}],
  "Motor Speed": [{label: `RPM`, y: "rpm"}, {least_domain: [-6_000, 6_000]}],
  "Motor Angle": [{label: "Ï†", y: "Ï†"}, {least_domain: [-Ï€, Ï€], units: "rad"}],
  "Torque": [
    [
      {label: `Ï„_{total}`, y: "Ï„_total"},
      {label: `Ï„_{emf}`, y: "Ï„_emf", stroke: color_x},
      {label: `Ï„_{friction}`, y: "Ï„_friction", stroke: color_y},
    ],
    {least_domain: [-0.010, +0.010], units: "Nm"},
  ],
  "Battery Current": [{label: "I_{bat}", y: "I"}, {least_domain: [-2.0, +2.0], units: "A"}],
  "Capacitor Voltage": [{label: "V_{near}", y: "V"}, {least_domain: [-12.0, +12.0], units: "V"}],
  "Radial Velocity": [
    [
      {label: `\nu_x`, y: "rx_v", stroke: color_x},
      {label: `\nu_y`, y: "ry_v", stroke: color_y},
    ],
    {least_domain: [-0.010, +0.010], units: "m/s"},
  ],
  "Radial displacement": [{label: "r", y: "r"}, {least_domain: [-0.000_010, +0.000_010], units: "m"}],
  "Radial Position": [
    [
      {label: "x", y: "rx", stroke: color_x},
      {label: "y", y: "ry", stroke: color_y},
    ],
    {least_domain: [-0.000_010, +0.000_010], units: "m"},
  ],
  "Currents": [
    [
      {label: "I_U", y: "I_u", stroke: color_u},
      {label: "I_V", y: "I_v", stroke: color_v},
      {label: "I_W", y: "I_w", stroke: color_w},
    ], 
    {least_domain: [-2.0, 2.0], height: 120, units: "A"},
  ],
  "Total EMF": [
    [
      {label: "V_U", y: "V_u_emf", stroke: color_u},
      {label: "V_V", y: "V_v_emf", stroke: color_v},
      {label: "V_W", y: "V_w_emf", stroke: color_w},
    ], 
    {least_domain: [-12.0, 12.0], height: 120, units: "V"},
  ],
  "Rotational EMF": [
    [
      {label: "V_U", y: "V_u_rotational_emf", stroke: color_u},
      {label: "V_V", y: "V_v_rotational_emf", stroke: color_v},
      {label: "V_W", y: "V_w_rotational_emf", stroke: color_w},
    ], 
    {least_domain: [-12.0, 12.0], height: 120, units: "V"},
  ],
  "Radial EMF": [
    [
      {label: "V_U", y: "V_u_radial_emf", stroke: color_u},
      {label: "V_V", y: "V_v_radial_emf", stroke: color_v},
      {label: "V_W", y: "V_w_radial_emf", stroke: color_w},
    ], 
    {least_domain: [-12.0, 12.0], height: 120, units: "V"},
  ],
  "VCC per phase": [
    [
      {label: "V_U", y: "VCC_u", stroke: color_u},
      {label: "V_V", y: "VCC_v", stroke: color_v},
      {label: "V_W", y: "VCC_w", stroke: color_w},
    ], 
    {least_domain: [-12.0, 12.0], height: 120, units: "V"},
  ],
  "Phase to phase inductor voltage": [
    [
      {label: "V_{UV}", y: "V_Luv", stroke: color_u},
      {label: "V_{VW}", y: "V_Lvw", stroke: color_v},
      {label: "V_{WU}", y: "V_Lwu", stroke: color_w},
    ], 
    {least_domain: [-12.0, 12.0], height: 120, units: "V"},
  ],
  "Phase to phase current change": [
    [
      {label: "dI_{UV}", y: "dI_uv", stroke: color_u},
      {label: "dI_{VW}", y: "dI_vw", stroke: color_v},
      {label: "dI_{WU}", y: "dI_wu", stroke: color_w},
    ], 
    {least_domain: [-10_000.0, +10_000.0], height: 120, units: "A/s"},
  ],
  "MOSFET voltage drop": [
    [
      {label: "V_U", y: "V_Mu", stroke: color_u},
      {label: "V_V", y: "V_Mv", stroke: color_v},
      {label: "V_W", y: "V_Mw", stroke: color_w},
    ], 
    {least_domain: [-1.0, 1.0], height: 120, units: "V"},
  ],
  "Switching direction": [
    [
      {label: "U", y: "U_direction", stroke: color_u},
      {label: "V", y: "V_direction", stroke: color_v},
      {label: "W", y: "W_direction", stroke: color_w},
    ], 
    {least_domain: [-1.0, 1.0], height: 120},
  ],
};

const default_simulation_plots = ["Currents", "Motor Speed", "Motor Angle", "Torque", "Total EMF", "Rotational EMF", "Radial EMF", "Radial Position", "Radial Velocity"];

const simulation_plots_selection = Inputs.checkbox(Object.keys(simulation_plots_map), {label: "Plots", value: default_simulation_plots});

const simulation_plots_preselections = Inputs.button(
  [
    ["Show Default", (value) => { 
      if (!value) value = simulation_plots_selection.value;
      simulation_plots_selection.value = default_simulation_plots;
      return value;
    }],
    ["Show All", (value) => {
      if (!value) value = simulation_plots_selection.value;
      simulation_plots_selection.value = Object.keys(simulation_plots_map); 
      return value;
    }],
    ["Hide Plots", (value) => {
      if (!value) value = simulation_plots_selection.value;
      simulation_plots_selection.value = []; 
      return value;
    }],
    ["User Selection", (value) => { if (value) simulation_plots_selection.value = value; return undefined;}],
  ],
  {label: "Plot selections"}
);

const simulation_plots_interface = htf`<span>
  <div>${simulation_plots_selection}</div>
  <div>${simulation_plots_preselections}</div>
  <div>${plot_labels_choice}</div>
</span>`;

const simulation_plots = Mutable();

const show_simulation_plots = _.throttle((history) => {

  simulation_plots.value = simulation_plots_selection.value.map((title) => {
    const [lines, options] = simulation_plots_map[title];
    return sparkline(history, title, lines, options);
  });
  
}, 1000.0/60);



function * simulate_live () {
  while(true){
    if (simulation.running()) {

      simulation.options.steps_number = Math.ceil(steps_number_slider.value);
      simulation.options.store_period = Math.ceil(store_period_slider.value);
      simulation.options.dt = 1.0 / frequency_slider.value;

      simulation.update();

      show_simulation_plots(_.takeRight(simulation.history, number_of_plot_points));

      update_motor_visuals(simulation.flattened_state());
    }
    
    rendering.render();

    show_simulation_info(simulation, rendering);

    yield rendering.div;
  }
}

```

```js
const live_simulation = simulate_live();
```

