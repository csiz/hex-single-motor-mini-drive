---
title: Understanding 3-phase motor control
---

<div class="grid" style="grid-template-columns: 1fr 1fr;">
  <div class="card">
    <figure>${live_simulation}</figure>
    <p>${highlight_description}</p>
  </div>
  <div class="card">
    <div class="card tight">${simulation_interface}</div>
    <div class="card tight">${simulation_info}</div>
    <span>${simulation_plots}</span>
  </div>
</div>


```js
import * as THREE from "three";
import {formatSI} from "format-si-prefix";

import {note, link, ThrottledMutable} from "./components/utils.js"
import {Simulation, initial_state, initial_parameters, π} from "./components/simulation.js"
import {create_scene, setup_rendering} from "./components/visuals.js"
import {sparkline} from "./components/plots.js"


const {motor, scene} = await create_scene();

const descriptions = new Map([
  ["<no selection>", html`
    We simulate a 3 phase motor with 1 winding per phase and 2 pole permanent magnet rotor
    (to simplify the illustration).`],
  [motor.stator, html`
    The stator is the stationary part of the motor. The coils wounded around the stator slots
    generate a magnetic field when current flows through them. The stator is made of magnetic
    material to guide the magnetic field lines between the stator poles. The hall sensors are
    also fixed to the stator, usually on a small circuit board, here they magically float.`],
  [motor.rotor, html`
    The rotor is the rotating part of the motor. The rotor contains permanent magnets that
    interact with the magnetic field generated by the stator. The rotor is mounted on a shaft
    that is supported by bearings.`],
  [motor.coil_U, html`
    The U phase coil generates a magnetic field when current flows through it. Driving the motor.`],
  [motor.coil_V, html`
    The V phase coil generates a magnetic field when current flows through it. Driving the motor.`],
  [motor.coil_W, html`
    The W phase coil generates a magnetic field when current flows through it. Driving the motor.`],
  [motor.hall_1, html`
    The hall sensor 1 is placed between the U and V phase poles. It senses the north magnetic field.`],
  [motor.hall_2, html`
    The hall sensor 2 is placed between the V and W phase poles. It senses the north magnetic field.`],
  [motor.hall_3, html`
    The hall sensor 3 is placed between the W and U phase poles. It senses the north magnetic field.`],
]);



const highlight_description = ThrottledMutable(500, descriptions.get("<no selection>"));

/* Get the most specific object group with a description from those intersected by the mouse cursor. */
function get_object_with_description(intersected_objects) {
  if (intersected_objects.length == 0) return [];
  let object = intersected_objects[0];
  // Walk the object hierarchy to find the first object with a description.
  while (!descriptions.has(object)) {
    // We reached the top without finding a description, don't highlight anything.
    if (object.parent == null) return [];
    object = object.parent;
  }
  return [object];
}

function show_description(objects) {
  highlight_description.value = descriptions.get(_.get(objects, "[0]", "<no selection>"));
}

const frequency_slider = Inputs.range([10_000, 100_000_000], {
  transform: Math.log, 
  format: x => x.toFixed(0), 
  label: "Frequency (Hz)",
});
const frequency = Generators.input(frequency_slider);

const steps_number_slider = Inputs.range([1, 20_000], {
  transform: Math.log, 
  format: x => x.toFixed(0), 
  label: "Steps per frame",
});
const steps_number = Generators.input(steps_number_slider);

const store_period_slider = Inputs.range([1, 10_000], {
  transform: Math.log, 
  format: x => x.toFixed(0), 
  label: "Store period",
});

const load_torque_slider = Inputs.range([-0.1, +0.1], {
  step: 0.001, 
  value: 0.0, 
  label: "Load Torque",
});


function interactive_inputs(state, parameters, outputs, update_memory) {
  return {
    U_switch: 0, // driver connection state for phase U
    V_switch: 0, // driver connection state for phase V
    W_switch: 0, // driver connection state for phase W
    τ_load: load_torque_slider.value, // external load torque
  }
}

function update_input(input, value) {
  input.value = value;
  input.dispatchEvent(new Event("input"));
}

function reset() {
  update_input(frequency_slider, 72_000_000); // 72 MHz
  update_input(store_period_slider, 2_000);
  update_input(steps_number_slider, 4_000);
  update_input(load_torque_slider, +0.1);
}

reset();


const rendering = setup_rendering(scene, invalidation, {highlight_filter: get_object_with_description, on_selection: show_description});
const fps = ThrottledMutable(100, 60.0);

let simulation = new Simulation({
  start_state: initial_state,
  parameters: initial_parameters,
  update_inputs: interactive_inputs,
  update_memory: {},
  dt: 1.0 / frequency_slider.value,
});

const simulation_control = Inputs.button(
  [
    ["Pause", () => { simulation.running = false; }], 
    ["Resume", () => { simulation.running = true; }],
    [html`<div style="min-width: 7em;">Look at motor</div>`, () => { rendering.reset_camera(); }],
    [html`<div style="min-width: 6em;">Reset inputs</div>`, () => { reset(); }],
  ],
  {value: "running", label: "Simulation control"}
);

function draw_sparklines(history){
  return html`<span>
    ${sparkline(history, {label: "Motor Speed (RPM)", y: "rpm"}, {domain: [-15_000, 15_000]})}
    ${sparkline(history, {label: "Motor Angle", y: "φ"}, {domain: [-π, π]})}
    ${sparkline(history, {label: "Load Torque", y: "τ_load"})}
    ${sparkline(
      history, [
        {label: "Current Iu", y: "Iu", stroke: "#a0a"},
        {label: "Current Iv", y: "Iv", stroke: "#aa0"},
        {label: "Current Iw", y: "Iw", stroke: "#0aa"},
      ], 
      {domain: [-6.0, 6.0], height: 120},
    )}
    ${sparkline(
      history, [
        {label: "EMF Vu", y: "Vu_rotational_emf", stroke: "#a0a"},
        {label: "EMF Vv", y: "Vv_rotational_emf", stroke: "#aa0"},
        {label: "EMF Vw", y: "Vw_rotational_emf", stroke: "#0aa"},
      ], 
      {domain: [-24.0, 24.0], height: 120},
    )}
    ${sparkline(
      history, [
        {label: "VCC Vu", y: "VCC_u", stroke: "#a0a"},
        {label: "VCC Vv", y: "VCC_v", stroke: "#aa0"},
        {label: "VCC Vw", y: "VCC_w", stroke: "#0aa"},
      ], 
      {domain: [-12.0, 12.0], height: 120},
    )}
    ${sparkline(
      history, [
        {label: "MOSFET Vu", y: "V_Mu", stroke: "#a0a"},
        {label: "MOSFET Vv", y: "V_Mv", stroke: "#aa0"},
        {label: "MOSFET Vw", y: "V_Mw", stroke: "#0aa"},
      ], 
      {domain: [-1.0, 1.0], height: 120},
    )}
  </span>`;
}


let simulation_plots = ThrottledMutable(1000.0/60.0);

let simulation_info = ThrottledMutable(300);

function * simulate_live () {
  while(true){
    if (simulation.running) {

      simulation.options.steps_number = Math.ceil(steps_number_slider.value);
      simulation.options.store_period = Math.ceil(store_period_slider.value);
      simulation.options.dt = 1.0 / frequency_slider.value;

      simulation.update();

      simulation_plots.value = draw_sparklines(simulation.history);

      simulation.update_graphics(motor, rendering.stats.fps);
    }
    
    rendering.render();

    simulation_info.value = html`<span style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr">
      <span>FPS: ${rendering.stats.fps.toFixed(1)}</span>
      <span>Slowdown: ${simulation.running ? formatSI(simulation.slowdown) : tex`\infty`}</span>
      <span>Speed: ${formatSI(1.0 / simulation.options.dt)}Hz</span>
      <span>${tex`\delta t`}: ${formatSI(simulation.options.dt)}s</span>
    </span>`;

    yield rendering.div;
  }
}

const live_simulation = simulate_live();

const simulation_interface = html`<span>
  <div>${simulation_control}</div>
  <div>${frequency_slider}</div>
  <div>${steps_number_slider}</div>
  <div>${store_period_slider}</div>
  <div>${load_torque_slider}</div>
</span>`;
```

