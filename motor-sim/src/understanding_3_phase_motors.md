---
title: Understanding 3-phase motor control
---

<div class="grid" style="grid-template-columns: 1fr 1fr;">
  <div class="card">
    <figure>${live_simulation}</figure>
    <p>${highlight_description}</p>
  </div>
  <div class="card">
    <div class="card tight">${simulation_interface}</div>
    <div class="card tight">${simulation_info}</div>
    <span>${simulation_plots}</span>
  </div>
</div>


```js
import * as THREE from "three";
import {formatSI} from "format-si-prefix";

import {note, link, ThrottledMutable} from "./components/utils.js"
import {Simulation, initial_state, initial_parameters, Ï€} from "./components/simulation.js"
import {create_scene, setup_rendering} from "./components/visuals.js"
import {sparkline} from "./components/plots.js"


const {motor, scene} = await create_scene();

function get_coil_color(coil) {
  const hsl_color = {};
  coil.material.emissive.getHSL(hsl_color);
  const {h, s, l} = hsl_color;

  return new THREE.Color().setHSL(h, 1.0, 0.3).getStyle();
}

const color_u = get_coil_color(motor.coil_U);
const color_v = get_coil_color(motor.coil_V);
const color_w = get_coil_color(motor.coil_W);
const color_x = "steelblue";
const color_y = "lightcoral";

const descriptions = new Map([
  ["<no selection>", html`
    We simulate a 3 phase motor with 1 winding per phase and 2 pole permanent magnet rotor
    (to simplify the illustration).`],
  [motor.stator, html`
    The stator is the stationary part of the motor. The coils wounded around the stator slots
    generate a magnetic field when current flows through them. The stator is made of magnetic
    material to guide the magnetic field lines between the stator poles. The hall sensors are
    also fixed to the stator, usually on a small circuit board, here they magically float.`],
  [motor.rotor, html`
    The rotor is the rotating part of the motor. The rotor contains permanent magnets that
    interact with the magnetic field generated by the stator. The rotor is mounted on a shaft
    that is supported by bearings.`],
  [motor.coil_U, html`
    The U phase coil generates a magnetic field when current flows through it. Driving the motor.`],
  [motor.coil_V, html`
    The V phase coil generates a magnetic field when current flows through it. Driving the motor.`],
  [motor.coil_W, html`
    The W phase coil generates a magnetic field when current flows through it. Driving the motor.`],
  [motor.hall_1, html`
    The hall sensor 1 is placed between the U and V phase poles. It senses the north magnetic field.`],
  [motor.hall_2, html`
    The hall sensor 2 is placed between the V and W phase poles. It senses the north magnetic field.`],
  [motor.hall_3, html`
    The hall sensor 3 is placed between the W and U phase poles. It senses the north magnetic field.`],
]);



const highlight_description = ThrottledMutable(500, descriptions.get("<no selection>"));

/* Get the most specific object group with a description from those intersected by the mouse cursor. */
function get_object_with_description(intersected_objects) {
  if (intersected_objects.length == 0) return [];
  let object = intersected_objects[0];
  // Walk the object hierarchy to find the first object with a description.
  while (!descriptions.has(object)) {
    // We reached the top without finding a description, don't highlight anything.
    if (object.parent == null) return [];
    object = object.parent;
  }
  return [object];
}

function show_description(objects) {
  highlight_description.value = descriptions.get(_.get(objects, "[0]", "<no selection>"));
}

const interactive_inputs_map = {
  "Disconnect Battery": ()=>[0, 0, 0],
  "Connect and Idle": ()=>[0, 0, 0],
  "Break": ()=>[2, 2, 2],
  "Drive -": (state, parameters, outputs, update_memory)=>sixstep_commutation(outputs, false),
  "Drive +": (state, parameters, outputs, update_memory)=>sixstep_commutation(outputs, true),
  "Drive U +": ()=>[1, 2, 2],
  "Drive V +": ()=>[2, 1, 2],
  "Drive W +": ()=>[2, 2, 1],
  "Drive U -": ()=>[2, 1, 1],
  "Drive V -": ()=>[1, 2, 1],
  "Drive W -": ()=>[1, 1, 2],
  "Drive UV +": ()=>[1, 2, 0],
  "Drive VW +": ()=>[0, 1, 2],
  "Drive WU +": ()=>[2, 0, 1],
  "Drive UV -": ()=>[2, 1, 0],
  "Drive VW -": ()=>[0, 2, 1],
  "Drive WU -": ()=>[1, 0, 2],
};

const frequency_slider = Inputs.range([10_000, 100_000_000], {
  transform: Math.log, 
  format: x => x.toFixed(0), 
  label: "Frequency (Hz)",
});
const frequency = Generators.input(frequency_slider);

const steps_number_slider = Inputs.range([1, 20_000], {
  transform: Math.log, 
  format: x => x.toFixed(0), 
  label: "Steps per frame",
});
const steps_number = Generators.input(steps_number_slider);

const store_period_slider = Inputs.range([1, 10_000], {
  transform: Math.log, 
  format: x => x.toFixed(0), 
  label: "Store period",
});

const load_torque_slider = Inputs.range([0.000_1, 0.1], {
  transform: Math.log,
  format: x => x.toFixed(4),
  label: "Load Torque",
});

const driver_state_selection = Inputs.radio(Object.keys(interactive_inputs_map), {label: "Driver control"});

function get_sixstep_hall_code(hall_1, hall_2, hall_3){
  return hall_3 << 2 | hall_2 << 1 | hall_1;
}

const sixstep_phase_map = {
  0b000: "no_magnet",
  0b100: 0,
  0b110: 1,
  0b010: 2,
  0b011: 3,
  0b001: 4,
  0b101: 5,
  0b111: "too_much_magnet",
};

const sixstep_switching_neg_map = {
  no_magnet: [0, 0, 0],
  too_much_magnet: [0, 0, 0],
  0: [0, 1, 2],
  1: [1, 0, 2],
  2: [1, 2, 0],
  3: [0, 2, 1],
  4: [2, 0, 1],
  5: [2, 1, 0],
};

const sixstep_switching_pos_map = {
  no_magnet: [0, 0, 0],
  too_much_magnet: [0, 0, 0],
  0: [0, 2, 1],
  1: [2, 0, 1],
  2: [2, 1, 0],
  3: [0, 1, 2],
  4: [1, 0, 2],
  5: [1, 2, 0],
};

function sixstep_commutation(outputs, positive=true){
  const {hall_1, hall_2, hall_3} = outputs;
  const sixstep_phase = sixstep_phase_map[get_sixstep_hall_code(hall_1, hall_2, hall_3)];
  return (positive ? sixstep_switching_pos_map : sixstep_switching_neg_map)[sixstep_phase];
}



function interactive_inputs(state, parameters, outputs, update_memory) {
  const [U_switch, V_switch, W_switch] = interactive_inputs_map[driver_state_selection.value](state, parameters, outputs, update_memory);

  return {
    U_switch, // driver connection state for phase U
    V_switch, // driver connection state for phase V
    W_switch, // driver connection state for phase W
    Ï„_load: load_torque_slider.value, // external load torque
    battery_connected: driver_state_selection.value != "Disconnect Battery", // whether the battery is connected
  }
}

function update_input(input, value) {
  input.value = value;
  input.dispatchEvent(new Event("input"));
}

function reset() {
  update_input(frequency_slider, 1_000_000); // We want to simulate 72 MHz!
  update_input(steps_number_slider, 20_000);
  update_input(store_period_slider, 250);
  update_input(load_torque_slider, +0.0001);
  update_input(driver_state_selection, "Connect and Idle");
}

reset();


const rendering = setup_rendering(scene, invalidation, {highlight_filter: get_object_with_description, on_selection: show_description});
const fps = ThrottledMutable(100, 60.0);

let simulation = new Simulation({
  start_state: initial_state,
  parameters: initial_parameters,
  update_inputs: interactive_inputs,
  update_memory: {},
  dt: 1.0 / frequency_slider.value,
});

const sound_scaling = {
  r: 1.0 / 0.002,
  rv: 1.0 / 1.0,
}

const simulation_control = Inputs.button(
  [
    ["Pause", () => { simulation.running = false; }], 
    ["Resume", () => { simulation.running = true; }],
    [html`<div style="min-width: 7em;">Look at motor</div>`, () => { rendering.reset_camera(); }],
    [html`<div style="min-width: 6em;">Reset inputs</div>`, () => { reset(); }],
    ["PlayðŸŽµ", () => {
      const audio_context = new AudioContext({sampleRate: simulation.options.sound_sample_rate});

      // Create an empty three-second stereo buffer at the sample rate of the AudioContext.
      const noise_buffer = audio_context.createBuffer(
        2,
        simulation.options.sound_buffer_size,
        simulation.options.sound_sample_rate,
      );

      const left_channel = noise_buffer.getChannelData(0);
      const right_channel = noise_buffer.getChannelData(1);

      const scaling = 1.0 / 0.002;

      simulation.sounds.forEach(({rx_v, ry_v, rx, ry}, i) => {
        left_channel[i] = scaling * rx;
        right_channel[i] = scaling * ry;
      });

      // Create a buffer source.
      const noise = audio_context.createBufferSource();
      noise.buffer = noise_buffer;

      // Connect to output.
      noise.connect(audio_context.destination);

      // Start the noise.
      noise.start();
    }],
  ],
  {value: "running", label: "Simulation control"}
);

function draw_sparklines(history){
  return html`<span>
    ${sparkline(history, {label: `Motor Speed (RPM)`, y: "rpm"}, {least_domain: [-6_000, 6_000]})}
    ${sparkline(history, {label: "Motor Angle", y: "Ï†"}, {least_domain: [-Ï€, Ï€]})}
    ${sparkline(history, {label: "Torque applied", y: "Ï„_applied"}, {least_domain: [-0.1, 0.1]})}
    ${sparkline(history, {label: "Battery Current", y: "I"}, {least_domain: [-2.0, +2.0]})}
    ${sparkline(history, {label: "Capacitor Voltage", y: "V"}, {least_domain: [-12.0, +12.0]})}
    ${sparkline(
      history, [
        {label: html`Radial ${tex`\nu_x`}`, y: "rx_v", stroke: color_x},
        {label: html`Radial ${tex`\nu_y`}`, y: "ry_v", stroke: color_y},
      ],
      {least_domain: [-0.1, +0.1]},
    )}
    ${sparkline(
      history, [
        {label: html`Radial ${tex`x`}`, y: "rx", stroke: color_x},
        {label: html`Radial ${tex`y`}`, y: "ry", stroke: color_y},
      ],
      {least_domain: [-0.000_100, +0.000_100]},
    )}
    ${sparkline(
      history, [
        {label: "Current Iu", y: "Iu", stroke: color_u},
        {label: "Current Iv", y: "Iv", stroke: color_v},
        {label: "Current Iw", y: "Iw", stroke: color_w},
      ], 
      {least_domain: [-2.0, 2.0], height: 120},
    )}
    ${sparkline(
      history, [
        {label: "EMF Vu", y: "Vu_emf", stroke: color_u},
        {label: "EMF Vv", y: "Vv_emf", stroke: color_v},
        {label: "EMF Vw", y: "Vw_emf", stroke: color_w},
      ], 
      {least_domain: [-12.0, 12.0], height: 120},
    )}
    ${sparkline(
      history, [
        {label: "EMF rot Vu", y: "Vu_rotational_emf", stroke: color_u},
        {label: "EMF rot Vv", y: "Vv_rotational_emf", stroke: color_v},
        {label: "EMF rot Vw", y: "Vw_rotational_emf", stroke: color_w},
      ], 
      {least_domain: [-12.0, 12.0], height: 120},
    )}
    ${sparkline(
      history, [
        {label: "EMF rad Vu", y: "Vu_radial_emf", stroke: color_u},
        {label: "EMF rad Vv", y: "Vv_radial_emf", stroke: color_v},
        {label: "EMF rad Vw", y: "Vw_radial_emf", stroke: color_w},
      ], 
      {least_domain: [-12.0, 12.0], height: 120},
    )}
  </span>`;
}

// Add all possible graphs with a checkbox system?
// ${sparkline(history, {label: "Radial displacement", y: "r"}, {least_domain: [-0.001, +0.001]})}
// ${sparkline(
//   history, [
//     {label: "VCC Vu", y: "VCC_u", stroke: color_u},
//     {label: "VCC Vv", y: "VCC_v", stroke: color_v},
//     {label: "VCC Vw", y: "VCC_w", stroke: color_w},
//   ], 
//   {least_domain: [-12.0, 12.0], height: 120},
// )}
// ${sparkline(
//   history, [
//     {label: "MOSFET Vu", y: "V_Mu", stroke: color_u},
//     {label: "MOSFET Vv", y: "V_Mv", stroke: color_v},
//     {label: "MOSFET Vw", y: "V_Mw", stroke: color_w},
//   ], 
//   {least_domain: [-1.0, 1.0], height: 120},
// )}
// ${sparkline(
//   history, [
//     {label: "U status", y: "U_status", stroke: color_u},
//     {label: "V status", y: "V_status", stroke: color_v},
//     {label: "W status", y: "W_status", stroke: color_w},
//   ], 
//   {least_domain: [-1.0, 1.0], height: 120},
// )}

let simulation_plots = ThrottledMutable(1000.0/60.0);

let simulation_info = ThrottledMutable(300);

function * simulate_live () {
  while(true){
    if (simulation.running) {

      simulation.options.steps_number = Math.ceil(steps_number_slider.value);
      simulation.options.store_period = Math.ceil(store_period_slider.value);
      simulation.options.dt = 1.0 / frequency_slider.value;

      simulation.update();

      simulation_plots.value = draw_sparklines(simulation.history);

      simulation.update_graphics(motor, rendering.stats.fps);
    }
    
    rendering.render();

    simulation_info.value = html`<span style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr">
      <span>FPS: ${rendering.stats.fps.toFixed(1)}</span>
      <span>Slowdown: ${simulation.running ? formatSI(simulation.slowdown) : tex`\infty`}</span>
      <span>Speed: ${formatSI(1.0 / simulation.options.dt)}Hz</span>
      <span>${tex`\delta t`}: ${formatSI(simulation.options.dt)}s</span>

      <span>Speed: ${formatSI(_.last(simulation.history).rpm)}RPM</span>
      <span>Radial: ${formatSI(_.last(simulation.history).r)}m</span>
      <span>Radial ${tex`\nu`}: ${formatSI(_.last(simulation.history).rv)}m/s</span>
      <span>ðŸŽµ buffer: ${formatSI(simulation.sound_buffer.size() / simulation.options.sound_sample_rate)}s</span>
    </span>`;

    yield rendering.div;
  }
}

const live_simulation = simulate_live();

const simulation_interface = html`<span>
  <div>${simulation_control}</div>
  <div>${frequency_slider}</div>
  <div>${steps_number_slider}</div>
  <div>${store_period_slider}</div>
  <div>${load_torque_slider}</div>
  <div>${driver_state_selection}</div>
</span>`;
```

